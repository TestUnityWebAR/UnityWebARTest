<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <title>Unity WebARProject</title>

    <!-- A-Frame + AR.js for NFT tracking -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar-nft.js"></script>

    <!-- Cosmetic, Look of the webpage-->
    <style>
      html, body {
        margin: 0; padding: 0; overflow: hidden; background: transparent;
      }
      #scene {
        position:absolute; top:0; left:0;
        width:100vw; height:100vh;
      }
      #unity-container,
      #unity-canvas,
      canvas {
        position:absolute; top:0; left:0;
        width:100vw; height:100vh;
        background:transparent !important;
        pointer-events:none;
      }
    </style>

    <script>
    AFRAME.registerComponent("cube-follow", { //Its like creating a function
      init() { //initialising
        //console.log("[cube-follow] init on", this.el); //Checking if the cube is indeed initialising
        this.spawned   = false; //bool set to false
        this.lostCount = 0; //tracking the number of times it has lost track
        this.marker    = this.el; //ref to the marker
        this.cam       = this.el.sceneEl.querySelector("[camera]"); //ref to the camera

        this.el.addEventListener("markerFound", () => {
          this.lostCount = 0;
          const u = window.unityInstance;
          if (!u?.SendMessage) return;
          //u.SendMessage("CubeSpawner","SetTracking",1);
          u.SendMessage("CubeSpawner","SpawnCube", this.marker.id); //(ScriptName, FunctionName, Function's parameter)
          this.spawned = true;
        });

        this.el.addEventListener("markerLost", () => {
          const u = window.unityInstance;
          u.SendMessage("CubeSpawner","DestroyCube", this.marker.id);
          this.spawned = false;
        });
      },

      tick() {
        const u = window.unityInstance;
        if (!u?.SendMessage || !this.spawned) return;

        // debounce small blips
        const vis = this.marker.object3D.visible;
        if (!vis) {
          if (++this.lostCount > 5) {
            console.log("[cube-follow] confirmed lost → destroying");
            u.SendMessage("CubeSpawner","DestroyCube", this.marker.id);
            //u.SendMessage("CubeSpawner","SetTracking",0);
            this.spawned   = false;
            this.lostCount = 0;
          }
          return;
        }
        this.lostCount = 0;

        //grab marker’s world‐space pose (in meters):
        const worldPos  = new THREE.Vector3();
        this.marker.object3D.getWorldPosition(worldPos);

        //grab orientation exactly as before
        const worldQuat = new THREE.Quaternion();
        this.marker.object3D.getWorldQuaternion(worldQuat);
        const camQuat   = new THREE.Quaternion();
        this.cam.object3D.getWorldQuaternion(camQuat);
        const relQuat   = camQuat.clone().invert().multiply(worldQuat);

        // //convert: mm→m, flip Z once, then optionally stretch & lift
        // const DIST_FACTOR = 3.0;    // This is where the cube will be placed, 
        // const Y_OFFSET    = 0.05;   //  5cm up so the cube sits atop the plane

        // const px = (worldPos.x/1000) * DIST_FACTOR;
        // const py = (worldPos.y/1000) * DIST_FACTOR + Y_OFFSET;
        // const pz = -(worldPos.z/1000) * DIST_FACTOR;

        // 2) convert to metres
        const posM = worldPos.clone().divideScalar(1000);

        // 3a) Vary by a factor of the real marker distance:
        const DIST_FACTOR = 2.5;  
        const spawnPosByFactor = posM.clone().multiplyScalar(DIST_FACTOR);

        // 3b) Or place at a fixed distance from the camera:
        const ABS_DIST = 2.0;  
        const dir       = posM.clone().normalize();  
        const spawnPosFixed = dir.clone().multiplyScalar(ABS_DIST);

        // 4) send whichever you like into Unity
        const p = spawnPosByFactor;  

        //send into Unity
        u.SendMessage(
          "CubeSpawner","UpdateTransformData",
          JSON.stringify({
            id: this.marker.id,
            position: { 
              x: p.x, 
              y: p.y, 
              z: p.z },
            rotation: {
              x: relQuat.x,
              y: relQuat.y,
              z: -relQuat.z,   // still single Z‐flip for handedness
              w: relQuat.w
            }
          })
        );
      }
    });
  </script>
  </head>

  <body>
    <!-- === AR.js Scene === -->
    <a-scene
      id="scene" embedded vr-mode-ui="enabled: false"
      renderer="logarithmicDepthBuffer: true; alpha: true"
      arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: true;"
    >
    <!-- 1st Marker-->
    <a-nft
      id="marker" 
      type="nft"
      url="UnityWebARTest/Descriptors/test2"
      smooth="true" 
      smoothCount="30"
      smoothTolerance="0.01" 
      smoothThreshold="5"
      detectMinSimilarity="0.3"
      scale="2 2 2"
      cube-follow
    >
    <a-light type="ambient" intensity="1"></a-light>
    </a-nft>

    <!-- 2nd Marker-->
    <a-nft
      id="marker2" 
      type="nft"
      url="UnityWebARTest/Descriptors/test3"
      smooth="true" 
      smoothCount="30"
      smoothTolerance="0.01" 
      smoothThreshold="5"
      detectMinSimilarity="0.3"
      scale="2 2 2"
      cube-follow
    >
    <a-light type="ambient" intensity="1"></a-light>
    </a-nft>
    <a-entity camera></a-entity>
    </a-scene>

    <!-- === Unity Canvas & Loading UI === -->
    <div id="unity-container">
      <canvas id="unity-canvas" width="960" height="600" tabindex="-1"></canvas>
      <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
          <div id="unity-progress-bar-full"></div>
        </div>
      </div>
      <div id="unity-warning"></div>
      <div id="unity-footer">
        <div id="unity-fullscreen-button"></div>
        <div id="unity-build-title">UnityWebARProject</div>
      </div>
    </div>

    <!-- === Unity Loader Script === -->
    <script>
      function unityShowBanner(msg, type) {
        const b = document.querySelector("#unity-warning"),
              d = document.createElement("div");
        d.innerHTML = msg;
        d.style = type==="error"
          ? "background:red;padding:10px;"
          : type==="warning"
          ? "background:yellow;padding:10px;" : "";
        b.appendChild(d);
        if(type==="warning") setTimeout(()=>b.removeChild(d),5000);
      }

      const canvas   = document.getElementById("unity-canvas");
      const loaderUrl= "Build/UnityWebARTest.loader.js";
      const config   = {
        dataUrl:    "Build/UnityWebARTest.data",
        frameworkUrl:"Build/UnityWebARTest.framework.js",
        codeUrl:    "Build/UnityWebARTest.wasm",
        streamingAssetsUrl:"StreamingAssets",
        showBanner: unityShowBanner,
        webglContextAttributes:{alpha:true,premultipliedAlpha:false}
      };

      console.log("Injecting Unity loader:", loaderUrl);
      const unityLoader = document.createElement("script");
      unityLoader.src = loaderUrl;
      unityLoader.onload = () => {
        console.log("Unity loader script loaded.");
        if (!window.unityInstance) {
          createUnityInstance(canvas, config, p => {
            document.querySelector("#unity-progress-bar-full")
                    .style.width = (100*p).toFixed(1) + "%";
          })
          .then(inst => {
            console.log("Unity instance created");
            window.unityInstance = inst;
            document.querySelector("#unity-loading-bar").style.display = "none";
          })
          .catch(err => {
            console.error("Unity load failed:", err);
            unityShowBanner("Unity failed to load","error");
          });
        }
      };
      unityLoader.onerror = e => {
        console.error("Error loading Unity loader script:", e);
        unityShowBanner("Could not load Unity loader.js","error");
      };
      document.body.appendChild(unityLoader);
    </script>
  </body>
</html>

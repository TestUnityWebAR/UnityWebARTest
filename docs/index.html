<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <title>Unity WebARProject</title>

    <!-- A-Frame + AR.js for NFT tracking -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar-nft.js"></script>

    <!-- Cosmetic, Look of the webpage-->
    <style>
      html, body {
        margin: 0; padding: 0; overflow: hidden; background: transparent;
      }
      #scene {
        position:absolute; top:0; left:0;
        width:100vw; height:100vh;
      }
      #unity-container,
      #unity-canvas,
      canvas {
        position:absolute; top:0; left:0;
        width:100vw; height:100vh;
        background:transparent !important;
        pointer-events:none;
      }
    </style>

    <script>
    Promise.all([
      fetch("StreamingAssets/functionManifest.json").then(r => r.json()),
      fetch("StreamingAssets/markerManifest.json").then(r => r.json())
    ])
    .then(([fnMan, mkMan]) => {
      // 1) Wire up Unity→JS stubs
      fnMan.functions.forEach(f => {
        window[f.jsName] = (...args) => {
          const payload = f.argCount === 1
            ? JSON.stringify(args[0])
            : JSON.stringify(args);
          window.unityInstance.SendMessage(f.objectName, f.methodName, payload);
        };
      });

      // 2) Inject <a-nft> + placeholder into A-Frame
      const scene = document.querySelector("a-scene");
      mkMan.urls.forEach(url => {
        const id  = url.split("/").pop();        // e.g. "amongus"
        const nft = document.createElement("a-nft");
        nft.setAttribute("id",                  id);
        nft.setAttribute("type",                "nft");
        nft.setAttribute("url",                 url);
        nft.setAttribute("smooth",              "true");
        nft.setAttribute("smoothCount",         "30");
        nft.setAttribute("smoothTolerance",     "0.01");
        nft.setAttribute("smoothThreshold",     "5");
        nft.setAttribute("detectMinSimilarity", "0.3");
        nft.setAttribute("scale",               "0.2 0.2 0.2");
        nft.setAttribute("cube-follow",         "");

        // --- HERE: create the placeholder entity at the marker center
        const placeholder = document.createElement("a-entity");
        placeholder.setAttribute("id", `${id}-ph`);
        placeholder.setAttribute("position", "0 0 0");
        // (it’s invisible by default, so no mesh needed)
        nft.appendChild(placeholder);

        // lighting (optional)
        const light = document.createElement("a-light");
        light.setAttribute("type",      "ambient");
        light.setAttribute("intensity", "1");
        nft.appendChild(light);

        scene.appendChild(nft);
      });
    })
    .catch(console.error);


    // 3) Single, unified cube-follow component
    AFRAME.registerComponent('cube-follow', {
      schema: {
        distanceFactor: { type: 'number', default: 1.5 },
        yOffset:        { type: 'number', default: 0.05 },
        smoothFactor:   { type: 'number', default: 0.2 }
      },

      init() {
        this.spawned    = false;
        this.lostCount  = 0;
        this.marker     = this.el;
        this.cameraEl   = this.el.sceneEl.querySelector('[camera]');

        this.smoothedPos  = new THREE.Vector3();
        this.smoothedQuat = new THREE.Quaternion();
        this.hasSmoothed  = false;

        const phId = () => `${this.marker.id}-ph`;

        this.marker.addEventListener('markerFound', () => {
          if (!this.spawned && window.unityInstance?.SendMessage) {
            window.unityInstance.SendMessage('CubeSpawner','SpawnCube', phId());
            this.spawned   = true;
            this.lostCount = 0;
          }
        });

        this.marker.addEventListener('markerLost', () => {
          if (this.spawned && window.unityInstance?.SendMessage) {
            window.unityInstance.SendMessage('CubeSpawner','DestroyCube', phId());
            this.spawned = false;
          }
        });
      },

      tick() {
        const u = window.unityInstance;
        if (!this.spawned || !u?.SendMessage) return;

        // debounce short drops
        if (!this.marker.object3D.visible && ++this.lostCount > 5) {
          u.SendMessage('CubeSpawner','DestroyCube', `${this.marker.id}-ph`);
          this.spawned   = false;
          this.lostCount = 0;
        }
        if (!this.marker.object3D.visible) return;
        this.lostCount = 0;

        // world-space marker & camera
        const worldPos  = new THREE.Vector3(), worldQuat = new THREE.Quaternion();
        this.marker.object3D.getWorldPosition(worldPos);
        this.marker.object3D.getWorldQuaternion(worldQuat);

        const camPos  = new THREE.Vector3(), camQuat  = new THREE.Quaternion();
        this.cameraEl.object3D.getWorldPosition(camPos);
        this.cameraEl.object3D.getWorldQuaternion(camQuat);

        // relative pose (mm)
        const relPosMm = worldPos.sub(camPos);
        const relQuat  = camQuat.clone().invert().multiply(worldQuat);

        // to metres
        const rawPos  = relPosMm.divideScalar(1000);
        const rawQuat = relQuat;

        // low-pass
        const α = this.data.smoothFactor;
        if (!this.hasSmoothed) {
          this.smoothedPos.copy(rawPos);
          this.smoothedQuat.copy(rawQuat);
          this.hasSmoothed = true;
        } else {
          this.smoothedPos.lerp(rawPos, α);
          this.smoothedQuat.slerp(rawQuat, α);
        }

        // scale & lift
        const df = this.data.distanceFactor, yf = this.data.yOffset, p = this.smoothedPos;
        const px = p.x * df, py = p.y * df + yf, pz = -p.z * df;

        // send into Unity under the placeholder id
        u.SendMessage(
          'CubeSpawner','UpdateTransformData',
          JSON.stringify({
            id:       `${this.marker.id}-ph`,
            position: { x:px, y:py, z:pz },
            rotation: {
              x: this.smoothedQuat.x,
              y: this.smoothedQuat.y,
              z: -this.smoothedQuat.z,
              w: this.smoothedQuat.w
            }
          })
        );
      }
    });
    </script>

  </head>

  <body>
    <!-- === AR.js Scene === -->
    <a-scene
      id="scene" embedded vr-mode-ui="enabled: false"
      renderer="logarithmicDepthBuffer: true; alpha: true"
      arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: true;"
    >
    <a-entity camera></a-entity>
    </a-scene>

    <!-- This is where they get the marker's ID, aka the images -->
<script>
  // 1) Load both manifests and inject your <a-nft> elements
  Promise.all([
    fetch("StreamingAssets/functionManifest.json").then(r => r.json()),
    fetch("StreamingAssets/markerManifest.json").then(r => r.json())
  ])
  .then(([fnMan, mkMan]) => {
    // Wire up Unity→JS stubs (unchanged)
    fnMan.functions.forEach(f => {
      window[f.jsName] = (...args) => {
        const payload = f.argCount === 1
          ? JSON.stringify(args[0])
          : JSON.stringify(args);
        window.unityInstance.SendMessage(f.objectName, f.methodName, payload);
      };
    });

    // Inject each NFT marker into the A-Frame scene
    const scene = document.querySelector("a-scene");
    mkMan.urls.forEach(url => {
      const id  = url.split("/").pop();
      const nft = document.createElement("a-nft");
      nft.setAttribute("id",                  id);
      nft.setAttribute("type",                "nft");
      nft.setAttribute("url",                 url);
      nft.setAttribute("smooth",              "true");
      nft.setAttribute("smoothCount",         "30");
      nft.setAttribute("smoothTolerance",     "0.01");
      nft.setAttribute("smoothThreshold",     "5");
      nft.setAttribute("detectMinSimilarity", "0.3");
      nft.setAttribute("scale",               "0.2 0.2 0.2");
      nft.setAttribute("cube-follow",         "");

      const light = document.createElement("a-light");
      light.setAttribute("type",      "ambient");
      light.setAttribute("intensity", "1");
      nft.appendChild(light);

      scene.appendChild(nft);
    });
  })
  .catch(console.error);

    // 2) Define cube-follow: always use marker.id as the Unity key
    AFRAME.registerComponent('cube-follow', {
      schema: {
        distanceFactor: { type: 'number', default: 1.5 },
        yOffset:        { type: 'number', default: 0.05 },
        smoothFactor:   { type: 'number', default: 0.2 }
      },

      init() {
        this.spawned    = false;
        this.lostCount  = 0;
        this.marker     = this.el;
        this.cameraEl   = this.el.sceneEl.querySelector('[camera]');

        this.smoothedPos  = new THREE.Vector3();
        this.smoothedQuat = new THREE.Quaternion();
        this.hasSmoothed  = false;

        // On detection, spawn under Unity GameObject named exactly marker.id
        this.marker.addEventListener('markerFound', () => {
          if (!this.spawned && window.unityInstance?.SendMessage) {
            window.unityInstance.SendMessage('CubeSpawner','SpawnCube', this.marker.id);
            this.spawned    = true;
            this.lostCount  = 0;
          }
        });

        // On loss, destroy that same Unity GameObject child
        this.marker.addEventListener('markerLost', () => {
          if (this.spawned && window.unityInstance?.SendMessage) {
            window.unityInstance.SendMessage('CubeSpawner','DestroyCube', this.marker.id);
            this.spawned = false;
          }
        });
      },

      tick() {
        const u = window.unityInstance;
        if (!this.spawned || !u?.SendMessage) return;

        // Debounce quick blips
        if (!this.marker.object3D.visible && ++this.lostCount > 5) {
          u.SendMessage('CubeSpawner','DestroyCube', this.marker.id);
          this.spawned   = false;
          this.lostCount = 0;
        }
        if (!this.marker.object3D.visible) return;
        this.lostCount = 0;

        // 1) world‐space marker + camera
        const worldPos  = new THREE.Vector3();
        const worldQuat = new THREE.Quaternion();
        this.marker.object3D.getWorldPosition(worldPos);
        this.marker.object3D.getWorldQuaternion(worldQuat);

        const camPos  = new THREE.Vector3();
        const camQuat = new THREE.Quaternion();
        this.cameraEl.object3D.getWorldPosition(camPos);
        this.cameraEl.object3D.getWorldQuaternion(camQuat);

        // 2) relative pose (mm)
        const relPosMm = worldPos.sub(camPos);
        const relQuat  = camQuat.clone().invert().multiply(worldQuat);

        // 3) to metres
        const rawPos  = relPosMm.divideScalar(1000);
        const rawQuat = relQuat;

        // 4) low‐pass filter
        const α = this.data.smoothFactor;
        if (!this.hasSmoothed) {
          this.smoothedPos.copy(rawPos);
          this.smoothedQuat.copy(rawQuat);
          this.hasSmoothed = true;
        } else {
          this.smoothedPos.lerp(rawPos, α);
          this.smoothedQuat.slerp(rawQuat, α);
        }

        // 5) scale & lift, still local to marker center
        const df      = this.data.distanceFactor;
        const yf      = this.data.yOffset;
        const p       = this.smoothedPos;
        const px      = p.x * df;
        const py      = p.y * df + yf;
        const pz      = -p.z * df;  // flip Z into scene

        // 6) send into Unity using the same marker.id key
        u.SendMessage(
          'CubeSpawner','UpdateTransformData',
          JSON.stringify({
            id:       this.marker.id,
            position: { x:px, y:py, z:pz },
            rotation: {
              x: this.smoothedQuat.x,
              y: this.smoothedQuat.y,
              z: -this.smoothedQuat.z,
              w: this.smoothedQuat.w
            }
          })
        );
      }
    });
  </script>
  </body>
</html>

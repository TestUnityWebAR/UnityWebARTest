<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <title>Unity WebARProject</title>

    <!-- A-Frame + AR.js for NFT tracking -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar-nft.js"></script>

    <!-- Cosmetic, Look of the webpage-->
    <style>
      html, body {
        margin: 0; padding: 0; overflow: hidden; background: transparent;
      }
      #scene {
        position:absolute; top:0; left:0;
        width:100vw; height:100vh;
      }
      #unity-container,
      #unity-canvas,
      canvas {
        position:absolute; top:0; left:0;
        width:100vw; height:100vh;
        background:transparent !important;
        pointer-events:none;
      }
    </style>

    <script>
    AFRAME.registerComponent('cube-follow', {
      schema: {
        distanceFactor: { type: 'number', default: 2.0 },
        yOffset:        { type: 'number', default: 0.05 },
        smoothFactor:   { type: 'number', default: 0.2 }
      },

      init() {
        this.spawned     = false;
        this.lostCount   = 0;
        this.marker      = this.el;
        this.cameraEl    = this.el.sceneEl.querySelector('[camera]');

        this.smoothedPos  = new THREE.Vector3();
        this.smoothedQuat = new THREE.Quaternion();
        this.hasSmoothed  = false;

        this.marker.addEventListener('markerFound', () => {
          if (!this.spawned && window.unityInstance?.SendMessage) {
            // use the placeholder id:
            const ph = `${this.marker.id}-ph`
            window.unityInstance.SendMessage('CubeSpawner','SpawnCube', ph);
            this.spawned = true;
            this.lostCount = 0;
          }
        });

        this.marker.addEventListener('markerLost', () => {
          const ph = `${this.marker.id}-ph`;
          if (this.spawned && window.unityInstance?.SendMessage) {
            window.unityInstance.SendMessage('CubeSpawner','DestroyCube', ph);
            this.spawned = false;
          }
        });
      },

      tick() {
        const u = window.unityInstance;
        if (!this.spawned || !u?.SendMessage) return;

        // debounce small blips
        if (!this.marker.object3D.visible && ++this.lostCount > 5) {
          u.SendMessage('CubeSpawner','DestroyCube', this.marker.id);
          this.spawned = false;
          this.lostCount = 0;
        }
        if (!this.marker.object3D.visible) return;
        this.lostCount = 0;

        // 1) get marker & camera world-space transforms
        const worldPos  = new THREE.Vector3();
        const worldQuat = new THREE.Quaternion();
        this.marker.object3D.getWorldPosition(worldPos);
        this.marker.object3D.getWorldQuaternion(worldQuat);

        const camPos   = new THREE.Vector3();
        const camQuat  = new THREE.Quaternion();
        this.cameraEl.object3D.getWorldPosition(camPos);
        this.cameraEl.object3D.getWorldQuaternion(camQuat);

        // 2) compute relative pose in mm
        const relPosMm = worldPos.sub(camPos);
        const relQuat  = camQuat.clone().invert().multiply(worldQuat);

        // 3) convert to metres
        const rawPos  = relPosMm.divideScalar(1000);
        const rawQuat = relQuat;

        // 4) low-pass filter
        const α = this.data.smoothFactor;
        if (!this.hasSmoothed) {
          this.smoothedPos.copy(rawPos);
          this.smoothedQuat.copy(rawQuat);
          this.hasSmoothed = true;
        } else {
          this.smoothedPos.lerp(rawPos, α);
          this.smoothedQuat.slerp(rawQuat, α);
        }

        // 5) apply scale & lift
        const df = this.data.distanceFactor;
        const yf = this.data.yOffset;
        const p  = this.smoothedPos;
        const px = p.x * df;
        const py = p.y * df + yf;
        const pz = -p.z * df;
        const ph = `${this.marker.id}-ph`

        // 6) send into Unity
        u.SendMessage(
          'CubeSpawner','UpdateTransformData',
          JSON.stringify({
            id: ph,
            position: { x: px, y: py, z: pz },
            rotation: {
              x: this.smoothedQuat.x,
              y: this.smoothedQuat.y,
              z: -this.smoothedQuat.z,
              w: this.smoothedQuat.w
            }
          })
        );
      }
    });
    </script>

  </head>

  <body>
    <!-- === AR.js Scene === -->
    <a-scene
      id="scene" embedded vr-mode-ui="enabled: false"
      renderer="logarithmicDepthBuffer: true; alpha: true"
      arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: true;"
    >
    <a-entity camera></a-entity>
    </a-scene>

    <!-- This is where they get the marker's ID, aka the images -->
<script>
  // 1) Load both manifests and inject your <a-nft> elements
  Promise.all([
    fetch("StreamingAssets/functionManifest.json").then(r => r.json()),
    fetch("StreamingAssets/markerManifest.json").then(r => r.json())
  ])
  .then(([fnMan, mkMan]) => {
    // Wire up Unity→JS stubs (unchanged)
    fnMan.functions.forEach(f => {
      window[f.jsName] = (...args) => {
        const payload = f.argCount === 1
          ? JSON.stringify(args[0])
          : JSON.stringify(args);
        window.unityInstance.SendMessage(f.objectName, f.methodName, payload);
      };
    });

    // Inject each NFT marker into the A-Frame scene
    const scene = document.querySelector("a-scene");
    mkMan.urls.forEach(url => {
      const id  = url.split("/").pop();
      const nft = document.createElement("a-nft");
      nft.setAttribute("id",                  id);
      nft.setAttribute("type",                "nft");
      nft.setAttribute("url",                 url);
      nft.setAttribute("smooth",              "true");
      nft.setAttribute("smoothCount",         "30");
      nft.setAttribute("smoothTolerance",     "0.01");
      nft.setAttribute("smoothThreshold",     "5");
      nft.setAttribute("detectMinSimilarity", "0.3");
      nft.setAttribute("scale",               "0.2 0.2 0.2");
      nft.setAttribute("cube-follow",         "");

      const light = document.createElement("a-light");
      light.setAttribute("type",      "ambient");
      light.setAttribute("intensity", "1");
      nft.appendChild(light);

      scene.appendChild(nft);
    });
  })
  .catch(console.error);

    // 2) Define cube-follow: always use marker.id as the Unity key
    AFRAME.registerComponent('cube-follow', {
      schema: {
        distanceFactor: { type: 'number', default: 1.5 },
        yOffset:        { type: 'number', default: 0.05 },
        smoothFactor:   { type: 'number', default: 0.2 }
      },

      init() {
        this.spawned    = false;
        this.lostCount  = 0;
        this.marker     = this.el;
        this.cameraEl   = this.el.sceneEl.querySelector('[camera]');

        this.smoothedPos  = new THREE.Vector3();
        this.smoothedQuat = new THREE.Quaternion();
        this.hasSmoothed  = false;

        // On detection, spawn under Unity GameObject named exactly marker.id
        this.marker.addEventListener('markerFound', () => {
          if (!this.spawned && window.unityInstance?.SendMessage) {
            window.unityInstance.SendMessage('CubeSpawner','SpawnCube', this.marker.id);
            this.spawned    = true;
            this.lostCount  = 0;
          }
        });

        // On loss, destroy that same Unity GameObject child
        this.marker.addEventListener('markerLost', () => {
          if (this.spawned && window.unityInstance?.SendMessage) {
            window.unityInstance.SendMessage('CubeSpawner','DestroyCube', this.marker.id);
            this.spawned = false;
          }
        });
      },

      tick() {
        const u = window.unityInstance;
        if (!this.spawned || !u?.SendMessage) return;

        // Debounce quick blips
        if (!this.marker.object3D.visible && ++this.lostCount > 5) {
          u.SendMessage('CubeSpawner','DestroyCube', this.marker.id);
          this.spawned   = false;
          this.lostCount = 0;
        }
        if (!this.marker.object3D.visible) return;
        this.lostCount = 0;

        // 1) world‐space marker + camera
        const worldPos  = new THREE.Vector3();
        const worldQuat = new THREE.Quaternion();
        this.marker.object3D.getWorldPosition(worldPos);
        this.marker.object3D.getWorldQuaternion(worldQuat);

        const camPos  = new THREE.Vector3();
        const camQuat = new THREE.Quaternion();
        this.cameraEl.object3D.getWorldPosition(camPos);
        this.cameraEl.object3D.getWorldQuaternion(camQuat);

        // 2) relative pose (mm)
        const relPosMm = worldPos.sub(camPos);
        const relQuat  = camQuat.clone().invert().multiply(worldQuat);

        // 3) to metres
        const rawPos  = relPosMm.divideScalar(1000);
        const rawQuat = relQuat;

        // 4) low‐pass filter
        const α = this.data.smoothFactor;
        if (!this.hasSmoothed) {
          this.smoothedPos.copy(rawPos);
          this.smoothedQuat.copy(rawQuat);
          this.hasSmoothed = true;
        } else {
          this.smoothedPos.lerp(rawPos, α);
          this.smoothedQuat.slerp(rawQuat, α);
        }

        // 5) scale & lift, still local to marker center
        const df      = this.data.distanceFactor;
        const yf      = this.data.yOffset;
        const p       = this.smoothedPos;
        const px      = p.x * df;
        const py      = p.y * df + yf;
        const pz      = -p.z * df;  // flip Z into scene

        // 6) send into Unity using the same marker.id key
        u.SendMessage(
          'CubeSpawner','UpdateTransformData',
          JSON.stringify({
            id:       this.marker.id,
            position: { x:px, y:py, z:pz },
            rotation: {
              x: this.smoothedQuat.x,
              y: this.smoothedQuat.y,
              z: -this.smoothedQuat.z,
              w: this.smoothedQuat.w
            }
          })
        );
      }
    });
  </script>
  </body>
</html>
